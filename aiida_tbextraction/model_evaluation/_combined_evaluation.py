# -*- coding: utf-8 -*-
"""
Implements a workchain to combine multiple evaluation processes.
"""

import numbers

from aiida import orm
from aiida.engine import Process, ToContext
from aiida_tools import get_outputs_dict
from aiida_tools.process_inputs import get_fullname, load_object

from ._base import ModelEvaluationBase


class CombinedEvaluation(ModelEvaluationBase):
    """WorkChain to combine multiple model evaluation methods.
    """
    @classmethod
    def define(cls, spec):
        super().define(spec)

        spec.input(
            'process_classes',
            valid_type=orm.List,
            help=
            "A list of process classes to be used for the individual evaluations. These can be given as a Python list of process classes, and will automatically be serialized for to an AiiDA List of strings.",
            serializer=cls._serialize_process_classes
        )
        spec.input(
            'labels',
            valid_type=orm.List,
            help="A list of labels for each of the process classes."
        )
        spec.input_namespace(
            'extra_inputs',
            dynamic=True,
            help=
            "Extra inputs for each of the evaluation processes. The inputs for each process should be given in an input namespace with the same name as the given 'label'."
        )
        spec.input(
            'weights',
            valid_type=orm.List,
            help='A list of weights for combining the cost values.'
        )
        spec.inputs.validator = cls._validate_inputs

        spec.exit_code(
            300, 'SUBPROCESS_FAILED', message="An evaluation process failed."
        )

        spec.output_namespace(
            'extra_outputs',
            dynamic=True,
            help="Outputs generated by the individual evaluation processes."
        )

        spec.outline(cls.launch_evaluations, cls.retrieve_evaluations)

    @staticmethod
    def _validate_inputs(inputs, ctx=None):  # pylint: disable=unused-argument,inconsistent-return-statements,too-many-return-statements
        """
        Checks that the 'process_classes', 'weights', and 'extra_inputs'
        inputs are consistent and of the right type.
        """
        if not (
            len(inputs['process_classes']) == len(inputs['labels']) ==
            len(inputs['weights'])
        ):
            return "The 'process_classes', 'labels', and 'weights' inputs must have the same length."

        process_classes = inputs['process_classes']
        if isinstance(process_classes, orm.List):
            if not all(isinstance(val, str) for val in process_classes):
                return "The 'process_classes' inputs must be string (if given as an AiiDA node)."
        else:
            if not all(issubclass(val, Process) for val in process_classes):
                return "The 'process_classes' inputs must be Process subclasses (if given as a Python list)."
        if not all(isinstance(val, str) for val in inputs['labels']):
            return "The 'labels' inputs must be string."
        if not all(val.isidentifier() for val in inputs['labels']):
            return "The 'labels' must be valid Python identifiers."
        if not all(isinstance(val, numbers.Real) for val in inputs['weights']):
            return "The 'weights' inputs must be real numbers."
        for label in inputs['extra_inputs']:
            if label not in inputs['labels']:
                return f"Extra inputs with label '{label}' have no corresponding entry in the 'labels' input."

    @staticmethod
    def _serialize_process_classes(input_list):
        return orm.List(
            list=[
                get_fullname(process_class).value
                for process_class in input_list
            ]
        )

    def launch_evaluations(self):
        """Launch the individual model evaluation processes."""
        processes = {}
        for label, process_class_string in zip(
            self.inputs.labels, self.inputs.process_classes
        ):
            process_class = load_object(process_class_string)
            processes[label] = self.submit(
                process_class,
                reference_structure=self.inputs.reference_structure,
                reference_bands=self.inputs.reference_bands,
                tb_model=self.inputs.tb_model,
                code_tbmodels=self.inputs.code_tbmodels,
                **self.inputs.extra_inputs.get(label, {})
            )

        return ToContext(**processes)

    def retrieve_evaluations(self):  # pylint: disable=inconsistent-return-statements
        """Retrieve the results of the individual model evaluations."""

        cost_value_result = 0.
        extra_outputs = {}
        for label, weight in zip(self.inputs.labels, self.inputs.weights):
            node = self.ctx[label]
            if not node.is_finished_ok:
                return self.exit_codes.SUBPROCESS_FAILED  # pylint: disable=no-member
            cost_value_result += weight * node.outputs.cost_value.value
            extra_outputs[label] = get_outputs_dict(node)
        # Note: breaking provenance of 'cost_value' here.
        self.out('cost_value', orm.Float(cost_value_result).store())
        self.out_many({'extra_outputs': extra_outputs})
